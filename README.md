# CS61B
![Image1](https://github.com/ajwwja777/git_exercise/raw/master/CS61BWebTitle.png)
[English version](README_en.md)  
[CS61B-extension](https://github.com/ajwwja777/CS61B-extension/tree/master)
### 前言与路线图
总结之前CS61A的经验，制定新的学习策略。
#### 1.输入
效率很重要。  
采用看视频和读文本交替的方式来学习，同时将提到的重要概念自己敲一敲。但也不要在此耗费太多时间。
#### 2.输出
在翻阅Calendar和Textbook之后，我发现T后面几乎没有习题建议了。  
因此，按照C的计划走，但在写lab/hw/proj的同时，要接着输入，不要死磕。
#### 3.效率
课程计划是15周，这太长了，我应该控制在8周左右。  
因此要详略得当，不要死磕，抓住核心思路。  
要有效率的学习，最好限时自己完成一件事情，不要陷入完美主义，把握主要思路即可，因为一些偏理论的细致末节的东西很快就会被忘掉，而应用的最多的才会被记住。
### Useful link
* [Course Website](https://sp18.datastructur.es/)  
- [Textbook](https://joshhug.gitbooks.io/hug61b/content/)  
* [Skeleton Code](https://github.com/Berkeley-CS61B/skeleton-sp18)
### 简单记录与总结
#### 模板1
`lec1 &lec2 & hw0 & lec3`只是完成cs61b阅读中java的基础语法，然后了解下java的值传递。`lec3`利用递归类定义创建了IntList,sll列表。intlist中利用了递归和迭代创建了实例方法。用p = this;迭代该索引。`lec4`sll中利用中间人类完成了对底层列表的访问，通过创建中间方法实现了size()方法。或者通过缓存来实现size方法。然后通过哨兵节点避免了addLast()的特殊情况。`lec5`看了下双链列表的last实现中头尾哨兵节点或者循环哨兵节点，但是自己根本没有实现。  
[来源](https://zhuanlan.zhihu.com/p/689818280)
#### 记录
`4.19`  
1. Complete the debug part and IntList part of lab2.  
2. Finish lec4, expect exercise part.  
3. Additionally, I find that the guide is very useful, including the lecture note and exercise, which is enough for me to study with lecture and hw/lab/proj.
4. At last, Efficiency! Lecture and exercise for understanding, hw/lab/proj for application, both are important.

`4.20`  
1. 今日计划  
   我在想是否只需要写hw/lab/proj。...做了exercise之后，想了一想，还是需要听课和写exercise，这对我帮助很大，不论在细节的思路上，还是在熟练度上。
2. 总结  
   完成了lec4 ex和lec5的全部。lec4 ex花了2h，lec5听得很快1h内，但是ex花了2h+，一开始连题目都看不太懂，最后还是勉强看完他人解答。最后很累...  
   总之，熟能生巧，慢慢来过，基础知识急不得，马虎不得。
   保持每天的持续性，每天一个lec和ex，不超过3h，再写hw/lab/proj。

